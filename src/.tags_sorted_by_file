!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
CPP	Makefile	/^CPP 		 = g++$/;"	m
CPPFLAGS	Makefile	/^CPPFLAGS = -std=c++14 -Wall -O3 -pthread$/;"	m
OBJ	Makefile	/^OBJ = slice.o latch.o latch_manager.o btree_page.o btree.o task.o queue.o iterator.o \\$/;"	m
main	Mushroom.cpp	/^int main(int argc, char **argv)$/;"	f
BTree	btree.cpp	/^BTree::BTree(const int fd, const int key_len):inserted_(0)$/;"	f	class:Mushroom::BTree
Close	btree.cpp	/^Status BTree::Close()$/;"	f	class:Mushroom::BTree
DescendToLeaf	btree.cpp	/^Latch* BTree::DescendToLeaf(const KeySlice *key, page_id *stack, uint8_t *depth) const$/;"	f	class:Mushroom::BTree
First	btree.cpp	/^BTreePage* BTree::First(page_id *page_no, int level) const$/;"	f	class:Mushroom::BTree
Get	btree.cpp	/^Status BTree::Get(KeySlice *key) const$/;"	f	class:Mushroom::BTree
Insert	btree.cpp	/^void BTree::Insert(Latch **latch, KeySlice *key)$/;"	f	class:Mushroom::BTree
KeyCheck	btree.cpp	/^bool BTree::KeyCheck(std::ifstream &in, int total) const$/;"	f	class:Mushroom::BTree
Mushroom	btree.cpp	/^namespace Mushroom {$/;"	n	file:
Next	btree.cpp	/^bool BTree::Next(KeySlice *key, page_id *page_no, uint16_t *index) const$/;"	f	class:Mushroom::BTree
Put	btree.cpp	/^Status BTree::Put(KeySlice *key)$/;"	f	class:Mushroom::BTree
SplitRoot	btree.cpp	/^Status BTree::SplitRoot(Latch *latch)$/;"	f	class:Mushroom::BTree
ToString	btree.cpp	/^std::string BTree::ToString() const$/;"	f	class:Mushroom::BTree
Traverse	btree.cpp	/^void BTree::Traverse(int level) const$/;"	f	class:Mushroom::BTree
BTree	btree.hpp	/^class BTree$/;"	c	namespace:Mushroom
KeyLen	btree.hpp	/^		uint8_t KeyLen() const { return key_len_; }$/;"	f	class:Mushroom::BTree
LM	btree.hpp	/^		const LatchManager* LM() const { return latch_manager_; }$/;"	f	class:Mushroom::BTree
MAX_KEY_LENGTH	btree.hpp	/^		static const int MAX_KEY_LENGTH = 256;$/;"	m	class:Mushroom::BTree
Mushroom	btree.hpp	/^namespace Mushroom {$/;"	n
_BTREE_HPP_	btree.hpp	9;"	d
degree_	btree.hpp	/^		uint16_t degree_;$/;"	m	class:Mushroom::BTree
inserted_	btree.hpp	/^		std::atomic<int> inserted_;$/;"	m	class:Mushroom::BTree
key_len_	btree.hpp	/^		uint8_t  key_len_;$/;"	m	class:Mushroom::BTree
latch_manager_	btree.hpp	/^		LatchManager *latch_manager_;$/;"	m	class:Mushroom::BTree
root_	btree.hpp	/^		BTreePage    *root_;$/;"	m	class:Mushroom::BTree
~BTree	btree.hpp	/^		~BTree() { delete latch_manager_; }$/;"	f	class:Mushroom::BTree
Analyze	btree_page.cpp	/^void BTreePage::Analyze() const$/;"	f	class:Mushroom::BTreePage
Ascend	btree_page.cpp	/^bool BTreePage::Ascend(KeySlice *key, page_id *page_no, uint16_t *idx)$/;"	f	class:Mushroom::BTreePage
CalculateDegree	btree_page.cpp	/^uint16_t BTreePage::CalculateDegree(uint8_t key_len, uint8_t pre_len)$/;"	f	class:Mushroom::BTreePage
Descend	btree_page.cpp	/^page_id BTreePage::Descend(const KeySlice *key) const$/;"	f	class:Mushroom::BTreePage
Insert	btree_page.cpp	/^InsertStatus BTreePage::Insert(const KeySlice *key, page_id &page_no)$/;"	f	class:Mushroom::BTreePage
Mushroom	btree_page.cpp	/^namespace Mushroom {$/;"	n	file:
NeedSplit	btree_page.cpp	/^bool BTreePage::NeedSplit()$/;"	f	class:Mushroom::BTreePage
NewPage	btree_page.cpp	/^BTreePage* BTreePage::NewPage(int type, uint8_t key_len, uint8_t level, uint16_t degree)$/;"	f	class:Mushroom::BTreePage
Read	btree_page.cpp	/^Status BTreePage::Read(const page_id page_no, const int fd)$/;"	f	class:Mushroom::BTreePage
Reset	btree_page.cpp	/^void BTreePage::Reset(page_id page_no, int type, uint8_t key_len, uint8_t level,$/;"	f	class:Mushroom::BTreePage
Search	btree_page.cpp	/^bool BTreePage::Search(KeySlice *key) const$/;"	f	class:Mushroom::BTreePage
Split	btree_page.cpp	/^void BTreePage::Split(BTreePage *that, KeySlice *slice)$/;"	f	class:Mushroom::BTreePage
ToString	btree_page.cpp	/^std::string BTreePage::ToString() const$/;"	f	class:Mushroom::BTreePage
Traverse	btree_page.cpp	/^bool BTreePage::Traverse(const KeySlice *key, uint16_t *idx, KeySlice **slice, int type) const$/;"	f	class:Mushroom::BTreePage
Write	btree_page.cpp	/^Status BTreePage::Write(const int fd)$/;"	f	class:Mushroom::BTreePage
ZERO	btree_page.cpp	/^uint64_t BTreePage::ZERO;$/;"	m	class:Mushroom::BTreePage	file:
AssignFirst	btree_page.hpp	/^		void AssignFirst(page_id first) {$/;"	f	class:Mushroom::BTreePage
AssignLevel	btree_page.hpp	/^		void AssignLevel(uint8_t level) { level_ = level; }$/;"	f	class:Mushroom::BTreePage
AssignPageNo	btree_page.hpp	/^		void AssignPageNo(page_id page_no) { page_no_ = page_no; }$/;"	f	class:Mushroom::BTreePage
AssignType	btree_page.hpp	/^		void AssignType(int type) { type_ = type; }$/;"	f	class:Mushroom::BTreePage
BRANCH	btree_page.hpp	/^		static enum { ROOT = 0, BRANCH, LEAF } TYPE;$/;"	e	enum:Mushroom::BTreePage::__anon2
BTreePage	btree_page.hpp	/^class BTreePage$/;"	c	namespace:Mushroom
Copy	btree_page.hpp	/^		void Copy(const BTreePage *that) { memcpy(this, that, PageSize); }$/;"	f	class:Mushroom::BTreePage
Data	btree_page.hpp	/^		const char* Data() const { return data_; }$/;"	f	class:Mushroom::BTreePage
Degree	btree_page.hpp	/^		uint16_t Degree() const { return degree_; }$/;"	f	class:Mushroom::BTreePage
ExistedKey	btree_page.hpp	/^typedef enum { InsertOk, ExistedKey, MoveRight } InsertStatus;$/;"	e	enum:Mushroom::__anon1
First	btree_page.hpp	/^		page_id First() const { return first_; }$/;"	f	class:Mushroom::BTreePage
GetPage	btree_page.hpp	/^		static BTreePage* GetPage(page_id page_no) {$/;"	f	class:Mushroom::BTreePage
Index	btree_page.hpp	/^		uint16_t* Index() const {$/;"	f	class:Mushroom::BTreePage
IndexByte	btree_page.hpp	/^		static const uint16_t IndexByte = 2;$/;"	m	class:Mushroom::BTreePage
InsertOk	btree_page.hpp	/^typedef enum { InsertOk, ExistedKey, MoveRight } InsertStatus;$/;"	e	enum:Mushroom::__anon1
InsertStatus	btree_page.hpp	/^typedef enum { InsertOk, ExistedKey, MoveRight } InsertStatus;$/;"	t	namespace:Mushroom	typeref:enum:Mushroom::__anon1
Key	btree_page.hpp	/^		KeySlice* Key(const uint16_t *index, int pos) const {$/;"	f	class:Mushroom::BTreePage
KeyLen	btree_page.hpp	/^		uint8_t KeyLen() const { return key_len_; }$/;"	f	class:Mushroom::BTreePage
KeyNum	btree_page.hpp	/^		uint16_t KeyNum() const { return total_key_; }$/;"	f	class:Mushroom::BTreePage
LEAF	btree_page.hpp	/^		static enum { ROOT = 0, BRANCH, LEAF } TYPE;$/;"	e	enum:Mushroom::BTreePage::__anon2
Level	btree_page.hpp	/^		uint8_t Level() const { return level_; }$/;"	f	class:Mushroom::BTreePage
MoveRight	btree_page.hpp	/^typedef enum { InsertOk, ExistedKey, MoveRight } InsertStatus;$/;"	e	enum:Mushroom::__anon1
Mushroom	btree_page.hpp	/^namespace Mushroom {$/;"	n
Next	btree_page.hpp	/^		page_id Next() const {$/;"	f	class:Mushroom::BTreePage
PageByte	btree_page.hpp	/^		static const uint16_t PageByte  = sizeof(page_id);$/;"	m	class:Mushroom::BTreePage
PageNo	btree_page.hpp	/^		page_id PageNo() const { return page_no_; }$/;"	f	class:Mushroom::BTreePage
PageSize	btree_page.hpp	/^		static const uint16_t PageSize  = 4096;$/;"	m	class:Mushroom::BTreePage
ROOT	btree_page.hpp	/^		static enum { ROOT = 0, BRANCH, LEAF } TYPE;$/;"	e	enum:Mushroom::BTreePage::__anon2
SetZero	btree_page.hpp	/^		static void SetZero(uint64_t offset) { ZERO = offset; }$/;"	f	class:Mushroom::BTreePage
TYPE	btree_page.hpp	/^		static enum { ROOT = 0, BRANCH, LEAF } TYPE;$/;"	m	class:Mushroom::BTreePage	typeref:enum:Mushroom::BTreePage::__anon2
Type	btree_page.hpp	/^		int Type() const { return type_; }$/;"	f	class:Mushroom::BTreePage
ZERO	btree_page.hpp	/^		static uint64_t ZERO;$/;"	m	class:Mushroom::BTreePage
_BTREE_PAGE_HPP_	btree_page.hpp	9;"	d
current	btree_page.hpp	/^		static std::atomic<uint32_t> current;$/;"	m	class:Mushroom::BTreePage
data_	btree_page.hpp	/^		char     data_[0];$/;"	m	class:Mushroom::BTreePage
degree_	btree_page.hpp	/^		uint16_t degree_;$/;"	m	class:Mushroom::BTreePage
dirty_	btree_page.hpp	/^		uint8_t  dirty_;$/;"	m	class:Mushroom::BTreePage
first_	btree_page.hpp	/^		page_id  first_;$/;"	m	class:Mushroom::BTreePage
key_len_	btree_page.hpp	/^		uint8_t  key_len_;$/;"	m	class:Mushroom::BTreePage
level_	btree_page.hpp	/^		uint8_t  level_;$/;"	m	class:Mushroom::BTreePage
page_no_	btree_page.hpp	/^		page_id  page_no_;$/;"	m	class:Mushroom::BTreePage
pre_len_	btree_page.hpp	/^		uint8_t  pre_len_;$/;"	m	class:Mushroom::BTreePage
total_key_	btree_page.hpp	/^		uint16_t total_key_;$/;"	m	class:Mushroom::BTreePage
type_	btree_page.hpp	/^		uint8_t  type_;$/;"	m	class:Mushroom::BTreePage
Close	db.cpp	/^Status MushroomDB::Close()$/;"	f	class:Mushroom::MushroomDB
Mushroom	db.cpp	/^namespace Mushroom {$/;"	n	file:
MushroomDB	db.cpp	/^MushroomDB::MushroomDB(const char *name, const int key_len, bool multi)$/;"	f	class:Mushroom::MushroomDB
Put	db.cpp	/^Status MushroomDB::Put(KeySlice *key)$/;"	f	class:Mushroom::MushroomDB
Btree	db.hpp	/^		const BTree* Btree() const { return btree_ ; }$/;"	f	class:Mushroom::MushroomDB
ClearTask	db.hpp	/^		void ClearTask() { if (pool_) pool_->Clear(); }$/;"	f	class:Mushroom::MushroomDB
Mushroom	db.hpp	/^namespace Mushroom {$/;"	n
MushroomDB	db.hpp	/^class MushroomDB$/;"	c	namespace:Mushroom
_MUSHROOM_DB_HPP_	db.hpp	11;"	d
btree_	db.hpp	/^		BTree      *btree_;$/;"	m	class:Mushroom::MushroomDB
name_	db.hpp	/^		std::string name_;$/;"	m	class:Mushroom::MushroomDB
pool_	db.hpp	/^		ThreadPool *pool_;$/;"	m	class:Mushroom::MushroomDB
~MushroomDB	db.hpp	/^		~MushroomDB() {$/;"	f	class:Mushroom::MushroomDB
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
Begin	iterator.cpp	/^bool Iterator::Begin()$/;"	f	class:Mushroom::Iterator
CheckBtree	iterator.cpp	/^bool Iterator::CheckBtree()$/;"	f	class:Mushroom::Iterator
Iterator	iterator.cpp	/^Iterator::Iterator(const BTree *btree, int level)$/;"	f	class:Mushroom::Iterator
Mushroom	iterator.cpp	/^namespace Mushroom {$/;"	n	file:
Next	iterator.cpp	/^bool Iterator::Next()$/;"	f	class:Mushroom::Iterator
Seek	iterator.cpp	/^bool Iterator::Seek(const char *key)$/;"	f	class:Mushroom::Iterator
Iterator	iterator.hpp	/^class Iterator$/;"	c	namespace:Mushroom
Key	iterator.hpp	/^		const KeySlice* Key() const { return key_; }$/;"	f	class:Mushroom::Iterator
Mushroom	iterator.hpp	/^namespace Mushroom {$/;"	n
_ITERATOR_HPP_	iterator.hpp	9;"	d
btree_	iterator.hpp	/^		const BTree *btree_;$/;"	m	class:Mushroom::Iterator
curr_	iterator.hpp	/^		page_id      curr_;$/;"	m	class:Mushroom::Iterator
index_	iterator.hpp	/^		uint16_t     index_;$/;"	m	class:Mushroom::Iterator
key_	iterator.hpp	/^		KeySlice    *key_;$/;"	m	class:Mushroom::Iterator
level_	iterator.hpp	/^		int          level_;$/;"	m	class:Mushroom::Iterator
~Iterator	iterator.hpp	/^		~Iterator() { if (key_) delete [] key_; key_ = nullptr; }$/;"	f	class:Mushroom::Iterator
Mushroom	latch.cpp	/^namespace Mushroom {$/;"	n	file:
Free	latch.hpp	/^		bool Free() const { return users_.load(std::memory_order_relaxed) == 0; }$/;"	f	class:Mushroom::Latch
Id	latch.hpp	/^		page_id Id() const { return id_; }$/;"	f	class:Mushroom::Latch
Latch	latch.hpp	/^		Latch():id_(0x7FFFFFFF) { assert(pthread_rwlock_init(&mutex_, NULL) == 0); }$/;"	f	class:Mushroom::Latch
Latch	latch.hpp	/^class Latch$/;"	c	namespace:Mushroom
Lock	latch.hpp	/^		void Lock() {$/;"	f	class:Mushroom::Latch
LockShared	latch.hpp	/^		void LockShared() {$/;"	f	class:Mushroom::Latch
Mushroom	latch.hpp	/^namespace Mushroom {$/;"	n
Pin	latch.hpp	/^		void Pin()   { ++users_; }$/;"	f	class:Mushroom::Latch
SetId	latch.hpp	/^		void SetId(page_id id) { id_ = id; }$/;"	f	class:Mushroom::Latch
ToString	latch.hpp	/^		std::string ToString() const {$/;"	f	class:Mushroom::Latch
UnPin	latch.hpp	/^		void UnPin() { --users_; }$/;"	f	class:Mushroom::Latch
Unlock	latch.hpp	/^		void Unlock() {$/;"	f	class:Mushroom::Latch
UnlockShared	latch.hpp	/^		void UnlockShared() {$/;"	f	class:Mushroom::Latch
Upgrade	latch.hpp	/^		void Upgrade() {$/;"	f	class:Mushroom::Latch
_LATCH_HPP_	latch.hpp	9;"	d
id_	latch.hpp	/^		page_id          id_;$/;"	m	class:Mushroom::Latch
mutex_	latch.hpp	/^		pthread_rwlock_t mutex_;$/;"	m	class:Mushroom::Latch
page_	latch.hpp	/^		BTreePage *page_;$/;"	m	class:Mushroom::Latch
users_	latch.hpp	/^		std::atomic<int> users_;$/;"	m	class:Mushroom::Latch
~Latch	latch.hpp	/^		~Latch() { assert(pthread_rwlock_destroy(&mutex_) == 0); }$/;"	f	class:Mushroom::Latch
GetLatch	latch_manager.cpp	/^Latch* LatchManager::GetLatch(page_id id)$/;"	f	class:Mushroom::LatchManager
GetLatch	latch_manager.cpp	/^Latch* LatchSet::GetLatch(page_id id)$/;"	f	class:Mushroom::LatchSet
Mushroom	latch_manager.cpp	/^namespace Mushroom {$/;"	n	file:
ToString	latch_manager.cpp	/^std::string LatchManager::ToString() const$/;"	f	class:Mushroom::LatchManager
ToString	latch_manager.cpp	/^std::string LatchSet::ToString() const$/;"	f	class:Mushroom::LatchSet
Hash	latch_manager.hpp	/^		static const int Hash = 16;$/;"	m	class:Mushroom::LatchManager
LatchManager	latch_manager.hpp	/^		LatchManager() { }$/;"	f	class:Mushroom::LatchManager
LatchManager	latch_manager.hpp	/^class LatchManager$/;"	c	namespace:Mushroom
LatchSet	latch_manager.hpp	/^		LatchSet() { }$/;"	f	class:Mushroom::LatchSet
LatchSet	latch_manager.hpp	/^class LatchSet$/;"	c	namespace:Mushroom
Mask	latch_manager.hpp	/^		static const int Mask = Hash - 1;$/;"	m	class:Mushroom::LatchManager
Max	latch_manager.hpp	/^		static const int Max = 8;$/;"	m	class:Mushroom::LatchSet
Mushroom	latch_manager.hpp	/^namespace Mushroom {$/;"	n
_LATCH_MANAGER_HPP_	latch_manager.hpp	9;"	d
latch_set_	latch_manager.hpp	/^		LatchSet    latch_set_[Hash];$/;"	m	class:Mushroom::LatchManager
latches_	latch_manager.hpp	/^		Latch      latches_[Max];$/;"	m	class:Mushroom::LatchSet
mutex_	latch_manager.hpp	/^		std::mutex mutex_;$/;"	m	class:Mushroom::LatchSet
Clear	queue.cpp	/^void Queue::Clear()$/;"	f	class:Mushroom::Queue
Mushroom	queue.cpp	/^namespace Mushroom {$/;"	n	file:
Pull	queue.cpp	/^void Queue::Pull()$/;"	f	class:Mushroom::Queue
Queue	queue.cpp	/^Queue::Queue(int capacity, uint8_t len):clear_(false), capacity_(capacity),$/;"	f	class:Mushroom::Queue
btree	queue.cpp	/^void Queue::Push(Status (BTree::*(fun))(KeySlice *), BTree *btree, KeySlice *key)$/;"	m	namespace:Mushroom	file:
~Queue	queue.cpp	/^Queue::~Queue()$/;"	f	class:Mushroom::Queue
Mushroom	queue.hpp	/^namespace Mushroom {$/;"	n
Queue	queue.hpp	/^class Queue$/;"	c	namespace:Mushroom
_QUEUE_HPP_	queue.hpp	11;"	d
avail_	queue.hpp	/^		std::vector<int>        avail_;$/;"	m	class:Mushroom::Queue
avail_back_	queue.hpp	/^		int                     avail_back_;$/;"	m	class:Mushroom::Queue
btree	queue.hpp	/^		void Push(Status (BTree::*(fun))(KeySlice *), BTree *btree, KeySlice *key);$/;"	m	class:Mushroom::Queue
capacity_	queue.hpp	/^		int                     capacity_;$/;"	m	class:Mushroom::Queue
clear_	queue.hpp	/^		bool                    clear_;$/;"	m	class:Mushroom::Queue
empty_	queue.hpp	/^		std::condition_variable empty_;$/;"	m	class:Mushroom::Queue
front_	queue.hpp	/^		int                     front_;$/;"	m	class:Mushroom::Queue
key	queue.hpp	/^		void Push(Status (BTree::*(fun))(KeySlice *), BTree *btree, KeySlice *key);$/;"	m	class:Mushroom::Queue
mutex_	queue.hpp	/^		std::mutex              mutex_;$/;"	m	class:Mushroom::Queue
queue_	queue.hpp	/^		std::vector<Task *>     queue_;$/;"	m	class:Mushroom::Queue
ready_	queue.hpp	/^		std::condition_variable ready_;$/;"	m	class:Mushroom::Queue
work_	queue.hpp	/^		std::vector<int>        work_;$/;"	m	class:Mushroom::Queue
work_back_	queue.hpp	/^		int                     work_back_;$/;"	m	class:Mushroom::Queue
Mushroom	slice.cpp	/^namespace Mushroom {$/;"	n	file:
ToString	slice.cpp	/^std::string Slice::ToString() const$/;"	f	class:Mushroom::Slice
form_string_	slice.cpp	/^std::function<std::string(const KeySlice *)> KeySlice::form_string_ = nullptr;$/;"	m	class:Mushroom::KeySlice	file:
AssignPageNo	slice.hpp	/^		void AssignPageNo(page_id page_no) { page_no_ = page_no; }$/;"	f	class:Mushroom::KeySlice
ComparePrefix	slice.hpp	/^	friend inline int ComparePrefix(const KeySlice *key, const char *prefix, size_t len) {$/;"	f	class:Mushroom::KeySlice
CompareSuffix	slice.hpp	/^	friend inline int CompareSuffix(const KeySlice *a, const KeySlice *b, size_t pre, size_t len)$/;"	f	class:Mushroom::KeySlice
CopyKey	slice.hpp	/^	friend inline void CopyKey(KeySlice *a, const KeySlice *b, size_t pre, size_t len) {$/;"	f	class:Mushroom::KeySlice
CopyPrefix	slice.hpp	/^	friend inline void CopyPrefix(KeySlice *a, const char *prefix, size_t len) {$/;"	f	class:Mushroom::KeySlice
Data	slice.hpp	/^		char* Data() { return data_; }$/;"	f	class:Mushroom::DataSlice
Data	slice.hpp	/^		char* Data() { return data_; }$/;"	f	class:Mushroom::KeySlice
Data	slice.hpp	/^		const char* Data() const { return data_; }$/;"	f	class:Mushroom::DataSlice
Data	slice.hpp	/^		const char* Data() const { return data_; }$/;"	f	class:Mushroom::KeySlice
Data	slice.hpp	/^		const char* Data() const { return data_; }$/;"	f	class:Mushroom::Slice
DataSlice	slice.hpp	/^		DataSlice() { }$/;"	f	class:Mushroom::DataSlice
DataSlice	slice.hpp	/^class DataSlice$/;"	c	namespace:Mushroom
KeySlice	slice.hpp	/^class KeySlice$/;"	c	namespace:Mushroom
Length	slice.hpp	/^		size_t Length() const { return len_; }$/;"	f	class:Mushroom::Slice
Length	slice.hpp	/^		uint16_t Length() const { return len_; }$/;"	f	class:Mushroom::DataSlice
LengthByte	slice.hpp	/^		static const int LengthByte = 2;$/;"	m	class:Mushroom::DataSlice
Mushroom	slice.hpp	/^namespace Mushroom {$/;"	n
PageNo	slice.hpp	/^		page_id PageNo() const { return page_no_; }$/;"	f	class:Mushroom::KeySlice
SetLength	slice.hpp	/^		void SetLength(uint16_t len) { len_ = len; }$/;"	f	class:Mushroom::DataSlice
SetStringFormat	slice.hpp	/^		static void SetStringFormat(const StringFormat &from_string) {$/;"	f	class:Mushroom::KeySlice
Slice	slice.hpp	/^		Slice():data_(nullptr), len_(0) { }$/;"	f	class:Mushroom::Slice
Slice	slice.hpp	/^		Slice(const char *data):data_(data), len_(strlen(data)) { }$/;"	f	class:Mushroom::Slice
Slice	slice.hpp	/^		Slice(const char *data, size_t len):data_(data), len_(len) { }$/;"	f	class:Mushroom::Slice
Slice	slice.hpp	/^class Slice$/;"	c	namespace:Mushroom
ToString	slice.hpp	/^		std::string ToString() const {$/;"	f	class:Mushroom::KeySlice
_SLICE_HPP_	slice.hpp	11;"	d
data_	slice.hpp	/^		char     data_[0];$/;"	m	class:Mushroom::DataSlice
data_	slice.hpp	/^		char     data_[0];$/;"	m	class:Mushroom::KeySlice
data_	slice.hpp	/^		const char *data_;$/;"	m	class:Mushroom::Slice
form_string_	slice.hpp	/^		static StringFormat form_string_;$/;"	m	class:Mushroom::KeySlice
len_	slice.hpp	/^		size_t      len_;$/;"	m	class:Mushroom::Slice
len_	slice.hpp	/^		uint16_t len_;$/;"	m	class:Mushroom::DataSlice
page_no_	slice.hpp	/^		page_id  page_no_;$/;"	m	class:Mushroom::KeySlice
that	slice.hpp	/^		Slice& operator=(const Slice &that) = delete;$/;"	m	class:Mushroom::Slice
Fail	status.hpp	/^enum Status {Fail = 0, Success, Fatal };$/;"	e	enum:Mushroom::Status
Fatal	status.hpp	/^enum Status {Fail = 0, Success, Fatal };$/;"	e	enum:Mushroom::Status
Mushroom	status.hpp	/^namespace Mushroom {$/;"	n
Status	status.hpp	/^enum Status {Fail = 0, Success, Fatal };$/;"	g	namespace:Mushroom
Success	status.hpp	/^enum Status {Fail = 0, Success, Fatal };$/;"	e	enum:Mushroom::Status
_STATUS_HPP_	status.hpp	11;"	d
page_id	status.hpp	/^typedef uint32_t page_id;$/;"	t	namespace:Mushroom
Mushroom	task.cpp	/^namespace Mushroom {$/;"	n	file:
Task	task.cpp	/^Task::Task(uint8_t key_len):fun_(nullptr), btree_(nullptr), key_(nullptr), key_len_(key_len)$/;"	f	class:Mushroom::Task
btree	task.cpp	/^void Task::Assign(Status (BTree::*(fun))(KeySlice *), BTree *btree, KeySlice *key)$/;"	m	namespace:Mushroom	file:
~Task	task.cpp	/^Task::~Task()$/;"	f	class:Mushroom::Task
Mushroom	task.hpp	/^namespace Mushroom {$/;"	n
Task	task.hpp	/^class Task$/;"	c	namespace:Mushroom
_TASK_HPP_	task.hpp	11;"	d
btree	task.hpp	/^		void Assign(Status (BTree::*(fun))(KeySlice *), BTree *btree, KeySlice *key);$/;"	m	class:Mushroom::Task
btree_	task.hpp	/^		BTree          *btree_;$/;"	m	class:Mushroom::Task
fun_	task.hpp	/^		Status         (BTree::*(fun_))(KeySlice *);$/;"	m	class:Mushroom::Task
key	task.hpp	/^		void Assign(Status (BTree::*(fun))(KeySlice *), BTree *btree, KeySlice *key);$/;"	m	class:Mushroom::Task
key_	task.hpp	/^		KeySlice       *key_;$/;"	m	class:Mushroom::Task
key_len_	task.hpp	/^		uint8_t         key_len_;$/;"	m	class:Mushroom::Task
operator ()	task.hpp	/^		Status operator()() { return (btree_->*fun_)(key_); }$/;"	f	class:Mushroom::Task
Clear	thread_pool.cpp	/^void ThreadPool::Clear()$/;"	f	class:Mushroom::ThreadPool
Mushroom	thread_pool.cpp	/^namespace Mushroom {$/;"	n	file:
Run	thread_pool.cpp	/^void ThreadPool::Run()$/;"	f	class:Mushroom::ThreadPool
Start	thread_pool.cpp	/^void Thread::Start()$/;"	f	class:Mushroom::Thread
Stop	thread_pool.cpp	/^void Thread::Stop()$/;"	f	class:Mushroom::Thread
ThreadPool	thread_pool.cpp	/^ThreadPool::ThreadPool(Queue *queue):queue_(queue), working_(false)$/;"	f	class:Mushroom::ThreadPool
btree	thread_pool.cpp	/^void ThreadPool::AddTask(Status (BTree::*(fun))(KeySlice *), BTree *btree, KeySlice *key)$/;"	m	namespace:Mushroom	file:
~ThreadPool	thread_pool.cpp	/^ThreadPool::~ThreadPool()$/;"	f	class:Mushroom::ThreadPool
CreateThread	thread_pool.hpp	/^		static std::shared_ptr<Thread> CreateThread(const std::function<void()> &func) {$/;"	f	class:Mushroom::ThreadPool
Id	thread_pool.hpp	/^		auto Id() const { return thread_.get_id(); }$/;"	f	class:Mushroom::Thread
Mushroom	thread_pool.hpp	/^namespace Mushroom {$/;"	n
Thread	thread_pool.hpp	/^		Thread(const std::function<void()> &func):func_(func) { }$/;"	f	class:Mushroom::Thread
Thread	thread_pool.hpp	/^class Thread$/;"	c	namespace:Mushroom
ThreadPool	thread_pool.hpp	/^class ThreadPool$/;"	c	namespace:Mushroom
_THREAD_POOL_HPP_	thread_pool.hpp	11;"	d
btree	thread_pool.hpp	/^		void AddTask(Status (BTree::*(fun))(KeySlice *), BTree *btree, KeySlice *key);$/;"	m	class:Mushroom::ThreadPool
func_	thread_pool.hpp	/^		std::function<void()>   func_;$/;"	m	class:Mushroom::Thread
key	thread_pool.hpp	/^		void AddTask(Status (BTree::*(fun))(KeySlice *), BTree *btree, KeySlice *key);$/;"	m	class:Mushroom::ThreadPool
queue_	thread_pool.hpp	/^		Queue                               *queue_;$/;"	m	class:Mushroom::ThreadPool
thread_	thread_pool.hpp	/^		std::thread             thread_;$/;"	m	class:Mushroom::Thread
threads_	thread_pool.hpp	/^		std::vector<std::shared_ptr<Thread>> threads_;$/;"	m	class:Mushroom::ThreadPool
working_	thread_pool.hpp	/^		bool                                 working_;$/;"	m	class:Mushroom::ThreadPool
Output	utility.hpp	/^void Output(const T *t, bool new_line = false) {$/;"	f
_UTILITY_HPP_	utility.hpp	11;"	d
